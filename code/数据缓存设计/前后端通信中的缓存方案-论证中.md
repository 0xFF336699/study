##### 注意这是前端方案，如果是后端自己的一些请求及缓存处理与此不同
要解决的问题  
*  前端会出现重复请求且返回是一样数据的  
*  后端查询数据占用cpu较多  
*  返回数据较多  

可能是普通方式的流程  
1. 前端请求  
2. 后端收到前端请求，根据请求的session获取到请求者的所在团队信息作为参数，到数据库查询数据。
3. 返回给前端对应的数据。  

现在设计构想的简化流程说明  

1. 前端跟普通相同的请求  
2. 后端不给返回传统返回的数据，而是返回请求对应的一个版本号
3. 前端通过这个版本号号到cdn请求数据  
4. 前端得到对应的数据  

解决方法  

1. 前端请求获取某信息的版本号   
2. 后端到redis查询该接口以及参数的缓存版本号，以及可能需要后端来补充的参数，例如根据session来补充请求者所属团队等的信息。       
> 例如前端请求参数var params = {"endpoint":"name","params":{"shopID":"abc"}} 
3. 到数据库（可以是redis也可以是关系型数据库），用redis举例，redis.get(params)。有则跳到第6步，没有则生成一个。  
> 生成方法和解释：  
> 如果直接拿params去cdn请求也可以，但是有时候有些数据会有隐秘性，例如某人所属团队，或者一组较长spu，每个sku都带有版本号，所以这时候会需要生成一个新版本号来进行隐藏数据和减少第二次请求的长度。  
> 去redis申请一个自增值  
> 为了防止被人枚举，这个值会用hashids来进行加密，如果被破解则抛弃这个加密的盐值，并清空已有的redis缓存即可。  
> 为什么不用uuid或md5而用hashids的原因是为了减少碰撞和储存大量uuid的话，再次生成需要消耗对比的成本。  
> redis自增保证了一致性，hashids进行了加密也保证了唯一性。  
4.  把这个自增值用hashids进行一次加密得到加密值，加密的盐可以采用全局、限定范围、当前本条，例如全局或者局部可以盐值"abc123"，本条数据则直接使用本条数据的参数做盐值即可。限定范围加盐可以避免将来被人破解全局需要重建缓存。  
> var hashids = new Hashids("this is my salt", 8, "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890");
> this is my salt可以替换为params  
> 当然 new Hashids的第二第三个参数可以设计规则来处理，不影响设计流程，不做过多展开。 
> 假设来了请求params，获得了redis的incr值是1，加密后得到的值是version = gB0NV05e  
   
5. 把加密值和请求参数作为一条数据的两个参数进行储存。
> 储存方式可以选择redis，用k/v来进行双向绑定。
> a) redis.setex(version, params, 根据被使用频率规则来的过期时间);  
> b) redis.set(params, version,根据被使用频率规则来的过期时间);
> 也可以选择其它数据库，例如关系型的数据库  
> kv表 insert into kv (version, params) values (version, params);

6. 把加密后的version返回给前端  
7. 前端用这个version当作url参数到cdn获取数据。例如url http://cdn.com/gB0NV05e
> 解释一下到cdn获取数据的原因  
> cdn在各个网络都可以比较快的获取数据  
> cdn可以有弹性带宽占用价格  
8. cdn在缓存中没有数据会到指定服务器去获取数据
9. 服务器收到cdn请求，根据url中的数据gB0NV05e（就是version）到redis去获取，redis.get(version)，如果这个version没有对应的key，那么应该是kv过期了，这是错误请求，会返回版本号错误的响应，前端应重新请求版本号。  
10. 通过version获取到了params，用params去查找对应的数据返回给cdn。
11. cdn把数据返回给前端。 一次请求就此完成。

每个接口在没有缓存或者缓存失效后是上面的流程，在第二次请求后的流程是
1. 对应上1
2. 对应上2
3. 对应上3，因为能拿到version了，所以跳到第6步
4. 对应上6
5. 对应上7
6. 上7的cdn那边已经有数据了，会直接返回数据。这步等于对应上11

综上，传统原先一个请求，现在改为了两次。先到后端获取当前请求对应的版本号，再到cdn获取版本号对应的数据  

  